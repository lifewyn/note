---
time: 2025-04-29
tags:
  - C
AG: scom
---

Okay, let's design a process that uses `lib60870-C` to act as an IEC 104 **Server (Slave)** and send data over the network. This server process will listen for connections, and once a client (like your "eth process") connects and requests data transfer, it will send data updates.

The "eth process" you mentioned would need to be implemented as an IEC 104 **Client (Master)** using the library (similar to the `cs104_client` example) to connect to this server process and receive the data.

Here's the design for the **Server (Slave) process** that sends data:

**Conceptual Design:**

1.  **Initialize Server:** Create and configure a `CS104_Slave` instance. Set the IP address and port it should listen on (e.g., all interfaces `0.0.0.0` on the default port `2404`).
2.  **Define Data Handling:** Implement callback functions to handle client connection requests, connection events, and specific commands like interrogation or clock sync (even if just basic responses are needed).
3.  **Start Server:** Start the `CS104_Slave` to begin listening for incoming client connections.
4.  **Data Generation Loop:** Run a loop or use an event-driven mechanism to:
    *   Read or generate the data you want to send (e.g., sensor values, status flags).
    *   Create appropriate IEC 104 Information Objects (e.g., timestamped measurements, timestamped single points) with unique Information Object Addresses (IOAs).
    *   Package these Information Objects into an ASDU (Application Service Data Unit) with the Cause of Transmission (COT) set to `CS101_COT_SPONTANEOUS`.
    *   Queue the ASDU for sending to all connected and active clients using `CS104_Slave_enqueueASDU`.
5.  **Shutdown:** Handle termination gracefully (e.g., using Ctrl+C), stopping the server and cleaning up resources.

**Implementation Steps (using `lib60870-C`):**

```c
#include <stdlib.h>
#include <stdbool.h>
#include <stdio.h>
#include <signal.h>
#include <unistd.h> // For sleep() or use Hal_Thread_sleep()

#include "cs104_slave.h"
#include "hal_thread.h"
#include "hal_time.h"

// --- Configuration ---
#define LISTEN_IP "0.0.0.0" // Listen on all interfaces
#define LISTEN_PORT IEC_60870_5_104_DEFAULT_PORT // 2404
#define DATA_SEND_INTERVAL_MS 1000 // Send data every second

// IOAs for your data points (replace with your actual addresses)
#define IOA_MEASUREMENT_1 1000
#define IOA_STATUS_1 2000

// --- Global State ---
static bool running = true;
static float current_measurement = 0.0f;
static bool current_status = false;

// --- Signal Handler ---
void sigint_handler(int signalId) {
    running = false;
    printf("Shutdown requested.\n");
}

// --- Callback Handlers (Implementations similar to simple_server.c) ---

// Optional: Accept all connections
static bool connectionRequestHandler(void* parameter, const char* ipAddress) {
    printf("Connection request from: %s\n", ipAddress);
    // Add logic here to allow/deny based on IP if needed
    return true;
}

// Log connection events
static void connectionEventHandler(void* parameter, IMasterConnection con, CS104_PeerConnectionEvent event) {
    if (event == CS104_CON_EVENT_CONNECTION_OPENED) {
        printf("Client connected (%p)\n", con);
    } else if (event == CS104_CON_EVENT_CONNECTION_CLOSED) {
        printf("Client disconnected (%p)\n", con);
    } else if (event == CS104_CON_EVENT_ACTIVATED) {
        printf("Client activated data transfer (%p)\n", con);
    } else if (event == CS104_CON_EVENT_DEACTIVATED) {
        printf("Client deactivated data transfer (%p)\n", con);
    }
}

// Handle General Interrogation (Example: Send current data)
static bool interrogationHandler(void* parameter, IMasterConnection connection, CS101_ASDU asdu, uint8_t qoi) {
    printf("Received interrogation for group %i\n", qoi);

    if (qoi == 20) { // Station interrogation
        CS101_AppLayerParameters alParams = IMasterConnection_getApplicationLayerParameters(connection);
        IMasterConnection_sendACT_CON(connection, asdu, false); // Send confirmation

        // Create ASDU for measurements (without timestamp for GI response)
        CS101_ASDU measuredValueAsdu = CS101_ASDU_create(alParams, false, CS101_COT_INTERROGATED_BY_STATION,
                                                        0, 1, false, false); // Common Addr 1
        InformationObject io_m = (InformationObject) MeasuredValueScaled_create(NULL, IOA_MEASUREMENT_1, (int)(current_measurement * 100), IEC60870_QUALITY_GOOD); // Example scaling
        CS101_ASDU_addInformationObject(measuredValueAsdu, io_m);
        InformationObject_destroy(io_m);
        IMasterConnection_sendASDU(connection, measuredValueAsdu);
        CS101_ASDU_destroy(measuredValueAsdu);

        // Create ASDU for status points (without timestamp for GI response)
         CS101_ASDU statusValueAsdu = CS101_ASDU_create(alParams, false, CS101_COT_INTERROGATED_BY_STATION,
                                                        0, 1, false, false); // Common Addr 1
        InformationObject io_s = (InformationObject) SinglePointInformation_create(NULL, IOA_STATUS_1, current_status, IEC60870_QUALITY_GOOD);
        CS101_ASDU_addInformationObject(statusValueAsdu, io_s);
        InformationObject_destroy(io_s);
        IMasterConnection_sendASDU(connection, statusValueAsdu);
        CS101_ASDU_destroy(statusValueAsdu);

        IMasterConnection_sendACT_TERM(connection, asdu); // Send termination
    } else {
        // Handle other QOIs or send negative confirmation
        IMasterConnection_sendACT_CON(connection, asdu, true); // Negative confirmation for unknown QOI
    }
    return true;
}

// Handle Clock Sync (Example: Just log it)
static bool clockSyncHandler (void* parameter, IMasterConnection connection, CS101_ASDU asdu, CP56Time2a newTime) {
    printf("Received Clock Sync command\n");
    // Optionally synchronize system time here
    return true; // Acknowledge command
}

// Handle other ASDUs (Example: Log unknown commands)
static bool asduHandler(void* parameter, IMasterConnection connection, CS101_ASDU asdu) {
    printf("Received unhandled ASDU TypeID: %d\n", CS101_ASDU_getTypeID(asdu));
    // Implement command handling (e.g., C_SC_NA_1) if needed
    return false; // Indicate not handled here (let library handle if possible)
}


// --- Main Process ---
int main(int argc, char** argv) {
    signal(SIGINT, sigint_handler);

    printf("Starting IEC 104 Server (Slave) process...\n");

    // 1. Create Slave
    CS104_Slave slave = CS104_Slave_create(100, 10); // Queue size 100, Max 10 connections

    // 2. Set Listen Address
    CS104_Slave_setLocalAddress(slave, LISTEN_IP);
    // CS104_Slave_setLocalPort(slave, LISTEN_PORT); // Usually not needed, defaults to 2404

    // 3. Set Handlers
    CS104_Slave_setConnectionRequestHandler(slave, connectionRequestHandler, NULL);
    CS104_Slave_setConnectionEventHandler(slave, connectionEventHandler, NULL);
    CS104_Slave_setInterrogationHandler(slave, interrogationHandler, NULL);
    CS104_Slave_setClockSyncHandler(slave, clockSyncHandler, NULL);
    CS104_Slave_setASDUHandler(slave, asduHandler, NULL);

    // Get Application Layer Parameters (needed for creating ASDUs)
    CS101_AppLayerParameters alParams = CS104_Slave_getAppLayerParameters(slave);

    // 4. Start Slave
    CS104_Slave_start(slave);

    if (CS104_Slave_isRunning(slave)) {
        printf("Server listening on %s:%d\n", LISTEN_IP, LISTEN_PORT);

        // 5. Data Generation and Sending Loop
        while (running) {
            // --- Simulate Data Acquisition ---
            // Replace this with your actual data reading logic
            current_measurement += 0.1f;
            if (current_measurement > 10.0f) current_measurement = 0.0f;
            current_status = !current_status;
            // --- End Data Acquisition ---


            // --- Create and Send Spontaneous Data ---
            // Note: Send data only if the server is running and potentially check if clients are connected/activated if needed
            if (CS104_Slave_isRunning(slave)) { // Basic check

                 // Create ASDU for timestamped measurement
                CS101_ASDU measurementAsdu = CS101_ASDU_create(alParams, false, CS101_COT_SPONTANEOUS, 0, 1, false, false);
                struct sCP56Time2a timestamp;
                CP56Time2a_createFromMsTimestamp(&timestamp, Hal_getTimeInMs());

                InformationObject io_m = (InformationObject) MeasuredValueScaledWithCP56Time2a_create(
                    NULL, IOA_MEASUREMENT_1, (int)(current_measurement * 100), IEC60870_QUALITY_GOOD, &timestamp); // Example scaling

                CS101_ASDU_addInformationObject(measurementAsdu, io_m);
                InformationObject_destroy(io_m); // Destroy IO after adding

                CS104_Slave_enqueueASDU(slave, measurementAsdu); // Enqueue for sending
                CS101_ASDU_destroy(measurementAsdu); // Destroy ASDU after enqueueing

                // Create ASDU for timestamped status point
                CS101_ASDU statusAsdu = CS101_ASDU_create(alParams, false, CS101_COT_SPONTANEOUS, 0, 1, false, false);
                // Reuse timestamp or create new one if needed
                CP56Time2a_createFromMsTimestamp(&timestamp, Hal_getTimeInMs());

                InformationObject io_s = (InformationObject) SinglePointWithCP56Time2a_create(
                    NULL, IOA_STATUS_1, current_status, IEC60870_QUALITY_GOOD, &timestamp);

                CS101_ASDU_addInformationObject(statusAsdu, io_s);
                InformationObject_destroy(io_s);

                CS104_Slave_enqueueASDU(slave, statusAsdu);
                CS101_ASDU_destroy(statusAsdu);


                printf("Sent spontaneous data: Measurement=%.2f, Status=%d\n", current_measurement, current_status);
            }

            // Wait before sending next update
            Thread_sleep(DATA_SEND_INTERVAL_MS);
        }

        // 6. Stop Slave
        CS104_Slave_stop(slave);
        printf("Server stopped.\n");

    } else {
        printf("ERROR: Failed to start server!\n");
    }

    // 7. Cleanup
    CS104_Slave_destroy(slave);
    printf("Server resources released.\n");

    return 0;
}
```

**To use this:**

1.  **Compile:** Compile this code, linking against the `lib60870-C` library. You'll likely need to adapt the `Makefile` or `CMakeLists.txt` from one of the examples.
2.  **Run:** Execute the compiled program. It will start listening.
3.  **Implement Client ("eth process"):** Create a separate IEC 104 client program (using `CS104_Connection`, similar to `simple_client.c`) that connects to the IP address and port where this server is running. The client needs to send STARTDT to begin receiving the spontaneous data updates. The client's `asduReceivedHandler` will process the incoming measurement and status ASDUs.

This design provides a basic server that periodically sends simulated data. You will need to replace the data simulation part with your actual data acquisition logic and define the correct Information Object Addresses (IOAs) and data types based on your specific requirements.
