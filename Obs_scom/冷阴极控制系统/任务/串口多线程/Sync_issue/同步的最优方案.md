---
time: 2025-02-06
tags:
  - thread
---
- [[解决多线程同步问题]]

The best solution in this case would be to use separate file descriptors for read and write operations. This approach completely eliminates the need for synchronization between read and write operations on the UART. Here's how to implement it:

```c
// ... existing code ...

struct uart_fd {
    int read_fd;
    int write_fd;
};

void *uart_read(void *arg)
{
    struct uart_fd *fds = (struct uart_fd *)arg;
    u_int16_t serial_bytes = 0;
    int packman_json_queue_id = get_sc_msg_queue_id(PACKMAN_JSON_QUEUE_KEY);

    struct sc_queue_msg rs232_send_data;
    memset(&rs232_send_data, 0, sizeof(struct sc_queue_msg));
    rs232_send_data.msg_type = SEND_MSG_TYPE;

    char serial_read_data[BUFFER_SIZE];
    memset(serial_read_data, '\0', BUFFER_SIZE*sizeof(char));

    while(1)
    {
        // Use read-only file descriptor
        serial_bytes = serial_read(fds->read_fd, serial_read_data);
        
        if(serial_bytes >= NORMAL_JSON_STR_SIZE)
        {
            syslog(LOG_INFO, "uart number is oversize the 128 bytes\r\n");
            continue;
        }

        if(check_wifi_data(fds->write_fd, serial_read_data, &serial_bytes) == 0)
        {
            continue;
        }

        fill_tx_msg(&rs232_send_data, serial_read_data, serial_bytes);
        queue_send_msg(packman_json_queue_id, &rs232_send_data);

        memset(serial_read_data, '\0', BUFFER_SIZE*sizeof(char));
        serial_bytes = 0;
        memset(&rs232_send_data, 0, sizeof(struct sc_queue_msg));
        rs232_send_data.msg_type = SEND_MSG_TYPE;
    }
}

void *uart_write(void *arg)
{
    struct uart_fd *fds = (struct uart_fd *)arg;
    u_int16_t serial_bytes = 0;

    char serial_write_buf[BUFFER_SIZE];
    memset(serial_write_buf, '\0', BUFFER_SIZE*sizeof(char));

    int rs232_rec_queue_id = get_sc_msg_queue_id(RS232_REC_QUEUE_KEY);

    struct sc_queue_msg rs232_rec_data;
    memset(&rs232_rec_data, 0, sizeof(struct sc_queue_msg));
    rs232_rec_data.msg_type = REC_MSG_TYPE;

    while(1)
    {
        queue_rec_msg(rs232_rec_queue_id, &rs232_rec_data);
        parse_rx_msg(serial_write_buf, &serial_bytes, &rs232_rec_data);
        
        // Use write-only file descriptor
        serial_write(fds->write_fd, serial_write_buf, serial_bytes);

        memset(serial_write_buf, '\0', BUFFER_SIZE*sizeof(char));
        serial_bytes = 0;
        memset(&rs232_rec_data, 0, sizeof(struct sc_queue_msg));
        rs232_rec_data.msg_type = REC_MSG_TYPE;
    }
}

int main()
{
    struct uart_fd fds;
    pthread_t uart_rec_tid;
    pthread_t uart_send_tid;

    // Open separate file descriptors for read and write
    fds.read_fd = open(SERIAL_PORT, O_RDONLY | O_NOCTTY);
    fds.write_fd = open(SERIAL_PORT, O_WRONLY | O_NOCTTY);

    if (fds.read_fd == -1 || fds.write_fd == -1) 
    {
        syslog(LOG_INFO, "Unable to open serial port");
        return EXIT_FAILURE;
    }
    else
    {
        syslog(LOG_INFO, "Serial open ok!\r\n");
    }

    // Configure both file descriptors
    configure_serial_port(fds.read_fd);
    configure_serial_port(fds.write_fd);

    if (daemon(0, 0) == -1)
    {
        syslog(LOG_INFO, "daemon");
        exit(EXIT_FAILURE);
    }

    // Create threads with the uart_fd structure
    int uart_rec_ret = pthread_create(&uart_rec_tid, NULL, uart_read, (void *)&fds);
    int uart_send_ret = pthread_create(&uart_send_tid, NULL, uart_write, (void *)&fds);

    if(uart_rec_ret != 0 || uart_send_ret != 0)
    {
        syslog(LOG_INFO, "create thread failed\n");
        return -1;
    }

    while(1)
    {
        syslog(LOG_INFO, "uart daemon is on");
        sleep(10);
    }

    pthread_join(uart_rec_tid, NULL);
    pthread_join(uart_send_tid, NULL);

    // Close both file descriptors
    close(fds.read_fd);
    close(fds.write_fd);

    return EXIT_SUCCESS;
}
```

--- 
This solution offers several advantages:

- No Synchronization Needed: Each thread has its own file descriptor, eliminating the need for mutex or any other synchronization mechanism.

- Better Performance: No blocking between read and write operations as they operate independently.

- Simpler Code: Removes all synchronization code, making the program simpler and more maintainable.

- More Reliable: Eliminates potential deadlocks and priority inversion issues that can occur with mutex-based solutions.

- Better Resource Management: Each thread has dedicated access to its file descriptor, preventing any potential interference.

--- 
Key considerations:

1. Make sure your UART driver supports multiple opens of the same device.

- The file descriptors should be opened with the appropriate flags (O_RDONLY for read, O_WRONLY for write).

3. Both file descriptors need to be properly configured with the same settings.

- Error handling should be implemented for both file descriptors.

This is generally considered the best solution because it:

- Provides true concurrent access

- Eliminates synchronization overhead

- Is simpler to implement and maintain

- Is more robust and reliable

- Has better performance characteristics

--- 
Thanks! Yes, using separate file descriptors is indeed an elegant solution.

To summarize the key benefits of this approach:

1. True Parallelism

- Read and write operations can happen simultaneously

- No thread blocking or waiting

- Clean Design

- No need for mutexes, semaphores, or condition variables

- Simpler code with fewer potential bugs

- Better Performance

- No synchronization overhead

- No context switching delays from lock contention

- Improved Reliability

- Eliminates deadlock possibilities

- No priority inversion issues

- More predictable behavior

This pattern can be useful in other similar scenarios where you need to handle bidirectional I/O with separate read/write threads. Just remember to always check if the underlying driver supports multiple opens of the device.