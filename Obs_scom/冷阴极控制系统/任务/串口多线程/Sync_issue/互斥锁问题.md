---
time: 2025-02-06
tags:
  - thread
---
- [[使用信号量的问题]]

Yes, when using a mutex, if the read thread holds the lock for too long, the write thread could be blocked, potentially causing delays or missed data. Here's a better approach using a circular buffer (ring buffer) with atomic operations, which can provide lock-free communication between the threads:

// ... existing code ...

#include <stdatomic.h>

#define RING_BUFFER_SIZE 2048  // Power of 2 for efficient wrapping

// Ring buffer structure
struct ring_buffer {
    uint8_t buffer[RING_BUFFER_SIZE];
    atomic_uint write_index;
    atomic_uint read_index;
};

static struct ring_buffer uart_buffer = {
    .write_index = 0,
    .read_index = 0
};

// Helper function to check if buffer is full
static inline bool ring_buffer_full(struct ring_buffer *rb) {
    return (((rb->write_index + 1) % RING_BUFFER_SIZE) == rb->read_index);
}

// Helper function to check if buffer is empty
static inline bool ring_buffer_empty(struct ring_buffer *rb) {
    return (rb->write_index == rb->read_index);
}

// Modified uart_read function
void *uart_read(void *arg)
{
    int *uart_rec_fd = (int *)arg;
    u_int16_t serial_bytes = 0;
    int packman_json_queue_id = get_sc_msg_queue_id(PACKMAN_JSON_QUEUE_KEY);
    char temp_buffer[BUFFER_SIZE];

    struct sc_queue_msg rs232_send_data;
    memset(&rs232_send_data, 0, sizeof(struct sc_queue_msg));
    rs232_send_data.msg_type = SEND_MSG_TYPE;

    while(1)
    {
        serial_bytes = read(*uart_rec_fd, temp_buffer, BUFFER_SIZE);
        if(serial_bytes > 0) {
            // Write to ring buffer
            for(int i = 0; i < serial_bytes; i++) {
                if(!ring_buffer_full(&uart_buffer)) {
                    uart_buffer.buffer[uart_buffer.write_index] = temp_buffer[i];
                    uart_buffer.write_index = (uart_buffer.write_index + 1) % RING_BUFFER_SIZE;
                } else {
                    syslog(LOG_WARNING, "Ring buffer full, dropping data");
                    break;
                }
            }
        }

        // Process the data
        char serial_read_data[BUFFER_SIZE];
        int data_len = 0;
        
        while(!ring_buffer_empty(&uart_buffer) && data_len < BUFFER_SIZE) {
            serial_read_data[data_len++] = uart_buffer.buffer[uart_buffer.read_index];
            uart_buffer.read_index = (uart_buffer.read_index + 1) % RING_BUFFER_SIZE;
        }

        if(data_len > 0) {
            if(data_len >= NORMAL_JSON_STR_SIZE) {
                syslog(LOG_INFO, "UART data exceeds normal size");
                continue;
            }

            serial_read_data[data_len] = '\0';
            
            if(check_wifi_data(*uart_rec_fd, serial_read_data, &data_len) == 0) {
                continue;
            }

            fill_tx_msg(&rs232_send_data, serial_read_data, data_len);
            queue_send_msg(packman_json_queue_id, &rs232_send_data);

            memset(&rs232_send_data, 0, sizeof(struct sc_queue_msg));
            rs232_send_data.msg_type = SEND_MSG_TYPE;
        }
    }
}

// Modified uart_write function
void *uart_write(void *arg)
{
    int *uart_send_fd = (int *)arg;
    char serial_write_buf[BUFFER_SIZE];
    u_int16_t serial_bytes = 0;

    int rs232_rec_queue_id = get_sc_msg_queue_id(RS232_REC_QUEUE_KEY);
    struct sc_queue_msg rs232_rec_data;
    memset(&rs232_rec_data, 0, sizeof(struct sc_queue_msg));
    rs232_rec_data.msg_type = REC_MSG_TYPE;

    while(1)
    {
        queue_rec_msg(rs232_rec_queue_id, &rs232_rec_data);
        
        parse_rx_msg(serial_write_buf, &serial_bytes, &rs232_rec_data);
        
        // Direct write without locking
        serial_write(*uart_send_fd, serial_write_buf, serial_bytes);

        memset(serial_write_buf, '\0', BUFFER_SIZE);
        serial_bytes = 0;
        memset(&rs232_rec_data, 0, sizeof(struct sc_queue_msg));
        rs232_rec_data.msg_type = REC_MSG_TYPE;
    }
}

// In main, remove mutex initialization and destruction
int main()
{
    // ... existing code ...
    
    // Remove mutex initialization
    
    int uart_rec_ret = pthread_create(&uart_rec_tid, NULL, uart_read, (void *)&fd);
    int uart_send_ret = pthread_create(&uart_send_tid, NULL, uart_write, (void *)&fd);
    
    // ... rest of the code ...
    
    // Remove mutex destruction
    return EXIT_SUCCESS;
}

--- 
This approach has several advantages:

- Lock-free Operation: No thread blocking, as it uses atomic operations instead of mutex locks

- Better Performance: Reduced contention between threads

- No Priority Inversion: Since there's no locking, you avoid priority inversion problems

- Data Buffering: The ring buffer helps handle bursts of data without losing information

Key considerations:

- The ring buffer size should be tuned based on your data rate and processing speed

- The buffer size should be a power of 2 for efficient wrapping

- This implementation assumes a single producer (read thread) and single consumer (write thread)

- You might want to add error handling for buffer overflow situations

This solution should prevent the write thread from being blocked while maintaining data integrity. The ring buffer acts as a FIFO queue between the read and write operations, allowing both threads to operate independently.