---
time: 2025-02-06
tags:
  - thread
---
- [[同步的最优方案]]


Here's how you could implement the UART communication using semaphores with the same file descriptor. This approach uses two semaphores to control access to read and write operations:

// ... existing code ...

#include <semaphore.h>

// Define semaphores for read and write operations
sem_t uart_read_sem;
sem_t uart_write_sem;

void *uart_read(void *arg)
{
    int *uart_rec_fd = (int *)arg;
    u_int16_t serial_bytes = 0;
    int packman_json_queue_id = get_sc_msg_queue_id(PACKMAN_JSON_QUEUE_KEY);

    struct sc_queue_msg rs232_send_data;
    memset(&rs232_send_data, 0, sizeof(struct sc_queue_msg));
    rs232_send_data.msg_type = SEND_MSG_TYPE;

    char serial_read_data[BUFFER_SIZE];
    memset(serial_read_data, '\0', BUFFER_SIZE*sizeof(char));

    while(1)
    {
        // Wait for read access
        sem_wait(&uart_read_sem);
        
        serial_bytes = serial_read(*uart_rec_fd, serial_read_data);
        
        // Release for write operations
        sem_post(&uart_write_sem);

        if(serial_bytes >= NORMAL_JSON_STR_SIZE)
        {
            syslog(LOG_INFO, "uart number is oversize the 128 bytes\r\n");
            continue;
        }

        if(check_wifi_data(*uart_rec_fd, serial_read_data, &serial_bytes) == 0)
        {
            continue;
        }

        fill_tx_msg(&rs232_send_data, serial_read_data, serial_bytes);
        queue_send_msg(packman_json_queue_id, &rs232_send_data);

        memset(serial_read_data, '\0', BUFFER_SIZE*sizeof(char));
        serial_bytes = 0;
        memset(&rs232_send_data, 0, sizeof(struct sc_queue_msg));
        rs232_send_data.msg_type = SEND_MSG_TYPE;
    }
}

void *uart_write(void *arg)
{
    int *uart_send_fd = (int *)arg;
    u_int16_t serial_bytes = 0;

    char serial_write_buf[BUFFER_SIZE];
    memset(serial_write_buf, '\0', BUFFER_SIZE*sizeof(char));

    int rs232_rec_queue_id = get_sc_msg_queue_id(RS232_REC_QUEUE_KEY);

    struct sc_queue_msg rs232_rec_data;
    memset(&rs232_rec_data, 0, sizeof(struct sc_queue_msg));
    rs232_rec_data.msg_type = REC_MSG_TYPE;

    while(1)
    {
        queue_rec_msg(rs232_rec_queue_id, &rs232_rec_data);
        parse_rx_msg(serial_write_buf, &serial_bytes, &rs232_rec_data);

        // Wait for write access
        sem_wait(&uart_write_sem);
        
        serial_write(*uart_send_fd, serial_write_buf, serial_bytes);
        
        // Release for read operations
        sem_post(&uart_read_sem);

        memset(serial_write_buf, '\0', BUFFER_SIZE*sizeof(char));
        serial_bytes = 0;
        memset(&rs232_rec_data, 0, sizeof(struct sc_queue_msg));
        rs232_rec_data.msg_type = REC_MSG_TYPE;
    }
}

int main()
{
    int fd = -1;
    pthread_t uart_rec_tid;
    pthread_t uart_send_tid;

    // Open serial port
    fd = open(SERIAL_PORT, O_RDWR);
    if (fd == -1) 
    {
        syslog(LOG_INFO, "Unable to open serial port");
        return EXIT_FAILURE;
    }

    // Configure serial port
    configure_serial_port(fd);

    // Initialize semaphores
    if (sem_init(&uart_read_sem, 0, 1) != 0) {  // Initialize with 1 to allow first read
        syslog(LOG_ERR, "Read semaphore initialization failed\n");
        return EXIT_FAILURE;
    }
    if (sem_init(&uart_write_sem, 0, 0) != 0) {  // Initialize with 0 to wait for first read
        syslog(LOG_ERR, "Write semaphore initialization failed\n");
        sem_destroy(&uart_read_sem);
        return EXIT_FAILURE;
    }

    if (daemon(0, 0) == -1)
    {
        syslog(LOG_INFO, "daemon");
        sem_destroy(&uart_read_sem);
        sem_destroy(&uart_write_sem);
        exit(EXIT_FAILURE);
    }

    // Create threads
    int uart_rec_ret = pthread_create(&uart_rec_tid, NULL, uart_read, (void *)&fd);
    int uart_send_ret = pthread_create(&uart_send_tid, NULL, uart_write, (void *)&fd);

    if(uart_rec_ret != 0 || uart_send_ret != 0)
    {
        syslog(LOG_INFO, "create thread failed\n");
        sem_destroy(&uart_read_sem);
        sem_destroy(&uart_write_sem);
        return EXIT_FAILURE;
    }

    while(1)
    {
        syslog(LOG_INFO, "uart daemon is on");
        sleep(10);
    }

    // Cleanup
    pthread_join(uart_rec_tid, NULL);
    pthread_join(uart_send_tid, NULL);
    
    sem_destroy(&uart_read_sem);
    sem_destroy(&uart_write_sem);
    close(fd);

    return EXIT_SUCCESS;
}

--- 
This semaphore-based solution has several characteristics:

Advantages:

1. More controlled access than mutex - you can specify the order of operations

- Better synchronization between read and write operations

- Can prevent potential race conditions

- Allows for more precise scheduling of operations

Disadvantages:

- Still introduces some blocking between threads

- More complex than the separate file descriptors solution

- Potential for deadlocks if not implemented carefully

- Slightly higher overhead than using separate file descriptors

Key Points:

- The read semaphore is initialized to 1 to allow the first read operation

- The write semaphore is initialized to 0 to wait for the first read to complete

- Each operation must wait for its turn using sem_wait()

- After completing an operation, the thread signals the other operation can proceed using sem_post()

While this solution works, it's generally less preferred than using separate file descriptors because:

- It still involves synchronization overhead

- It doesn't allow true parallel operation

- It's more complex to implement correctly

- It can be more prone to timing-related issues

The separate file descriptors solution remains the cleaner and more efficient approach if your system supports it.